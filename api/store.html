<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title># Block Stores</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Blocks</span> <span class="project-version">2.0.2</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="store.html"><div class="inner"><span># Block Stores</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>blocks</span></div></div></li><li class="depth-2 branch"><a href="blocks.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="blocks.meter.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>meter</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>store</span></div></div></li><li class="depth-3 branch"><a href="blocks.store.buffer.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>buffer</span></div></a></li><li class="depth-3 branch"><a href="blocks.store.cache.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cache</span></div></a></li><li class="depth-3 branch"><a href="blocks.store.file.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>file</span></div></a></li><li class="depth-3 branch"><a href="blocks.store.memory.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>memory</span></div></a></li><li class="depth-3"><a href="blocks.store.replica.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>replica</span></div></a></li><li class="depth-2"><a href="blocks.summary.html"><div class="inner"><span class="tree" style="top: -176px;"><span class="top" style="height: 185px;"></span><span class="bottom"></span></span><span>summary</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h2><a href="#block-stores" name="block-stores"></a>Block Stores</h2>
<p>The block store protocol defines the methods necessary for implementing a block storage backend. The interface is simple enough to map to many different kinds of storage, and the library comes with basic in-memory and file-based stores.</p>
<h3><a href="#implementation-decisions" name="implementation-decisions"></a>Implementation Decisions</h3>
<p>There are a few questions you need to answer if you decide to implement a block store.</p>
<h4><a href="#laziness" name="laziness"></a>Laziness</h4>
<p>Will your store return <em>loaded</em> or <em>lazy</em> blocks? The former requires pulling the block data into memory when fetching the block, while the latter only fetches the data when the block’s content is read.</p>
<p>Different choices make sense for different backends; for example, a persistent store backed by cloud storage can usually depend on the data being there later, so lazy blocks are much more efficient. For a store based on a remote cache, it would be better to pull the block content on fetch because the data might be evicted before the block is read.</p>
<h4><a href="#asynchrony" name="asynchrony"></a>Asynchrony</h4>
<p>The block store methods are intended to be asynchronous, to enable efficient usage in concurrent environments. This project uses the excellent <a href="https://github.com/ztellman/manifold">manifold</a> library for an adaptable async framework. If there’s no underlying asynchronous system to tie into in the storage backend, you can just wrap the synchronous calls in <code>manifold.deferred/future</code> to put them on a thread-pool.</p>
<h4><a href="#metadata" name="metadata"></a>Metadata</h4>
<p>Blocks support Clojure metadata, so any additional information the store needs to communicate can be added to the blocks as metadata. This intentionally doesn’t affect block equality or semantics, but can be useful for introspection.</p>
<p>For example, a common piece of useful metadata is a URI for the concrete location of the block’s data in the backing store.</p>
<h3><a href="#storage-protocol" name="storage-protocol"></a>Storage Protocol</h3>
<p>Block stores must implement five methods.</p>
<h4><a href="#list" name="list"></a>list</h4>
<p>The <code>list</code> method enumerates the blocks contained in the store as a <a href="https://github.com/ztellman/manifold/blob/master/docs/stream.md">Manifold stream</a>, ordered by the blocks’ multihash identifier.</p>
<p>A few simple query criteria are supported to return ranges of blocks whose id uses a specific algorithm, or falls before or after some given hex markers. The implementation of this method must return <em>at least</em> the blocks which match the query options, and <em>should</em> optimize the results by omitting unmatched blocks when possible.</p>
<p>In practice, when this method is called the store should spin up an asynchronous process (usually a thread via <code>d/future</code>) that interrogates the storage layer and emits the resulting blocks on an output stream, which is returned to the caller. This stream may be closed preemptively if the consumer is done, which should cleanly terminate the listing process.</p>
<p>If the listing encounters an exception, the error should be placed on the stream and the stream should be closed to indicate no further blocks will be coming. Consumers must handle exceptions propagated on the stream in this fashion.</p>
<h4><a href="#stat" name="stat"></a>stat</h4>
<p>The <code>stat</code> method is used to return metadata about a block if the store contains it. This should return a deferred which yields the info, or <code>nil</code> if the store does not contain the requested block.</p>
<p>This is very similar to <code>get</code>, but returns a regular Clojure map instead of a block. This map should have the same <code>:id</code>, <code>:size</code>, and <code>:stored-at</code> values as well as the same metadata a block returned from <code>get</code> would. Conceptually, this is similar to the <code>HEAD</code> vs <code>GET</code> verbs in HTTP.</p>
<p>This distinction is useful for stores which return loaded blocks, like a cache - using <code>stat</code> allows the caller to avoid the extra IO for block content which will not be used.</p>
<h4><a href="#get" name="get"></a>get</h4>
<p>This method fetches a block from the store. This should return a deferred which yields the block, or nil if not present.</p>
<h4><a href="#put-" name="put-"></a>put!</h4>
<p>Putting a block persists it into the store. This should return a deferred which yields the stored block. If the store already contains this block, then the implementation <em>should</em> avoid re-storing or other data transfer to the storage layer, and return the already-stored block directly.</p>
<h4><a href="#delete-" name="delete-"></a>delete!</h4>
<p>Deleting a block removes it from the store. This should return a deferred which yields true if the block was stored, false if it was not.</p>
<h3><a href="#erasable-protocol" name="erasable-protocol"></a>Erasable Protocol</h3>
<p>Stores may optionally add support for the <code>ErasableStore</code> protocol, which provides an efficient mechanism for completely removing the backend data. If not implemented, the <code>erase!</code> function will fall back to listing and deleting all blocks.</p></div></div></div></body></html>